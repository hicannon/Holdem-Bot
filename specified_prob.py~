import framework
import numpy

class specified_prob(framework.Auto_player):
    def __init__(self, neural_net, stat=None, name="anonymous", 
                 prob_list={'Check':0.25, 'Call', 0.25, 'Raise', 0.25, 
                            'CheckFold':0.25}):
        self.net=neural_net
        self.name=name
        if stat==None:
            self.status=Status()
        else:
            self.status=stat
        self.prob_list=prob_list
    def decision_helper(self):
        x=numpy.random.rand()
        if x < prob_list['Check']:
            return 'Check'
        else if x<prob_list['Check']+prob_list['Call']:
            return 'Call'
        else if x< prob_list['Check']+prob_list['Call']+prob_list['Raise']:
            return 'Raise'
        else:
            return 'CheckFold'
    def decision(self, player2, game0, playerNum, debug=0):
        #make decision on next move
        if debug:
            print "it's "+self.name+" 's turn!"
        possible_next=[]
        current= self.status
        stage=current.stage
        if (stage>0 and current.vec_act[stage][0]==0 and 
            current.dealer==0 and player2.status.vec_act[stage][0]==0):
           #this is the case when you are the first to act in a post-flop round
            possible_next=[current.check_first(), current.praise()]
            game_actions = ["Check", "Raise"]
        elif (current.vec_act[stage][1]< 4*basebet(stage)):
           #this is the case when you are not in first case, and you may still
           #raise
            possible_next=[current.check_fold(), 
                           current.call(), current.praise()]
            game_actions = ["CheckFold", "Call", "Raise"]
        else:
           #all other cases
            possible_next=[current.check_fold(), current.call()]
            game_actions = ["CheckFold", "Call"]
        action=decision_helper(self)
        while action not in game_actions:
            action=decision_helper(self)
        index=game_actions.index(action)
        self.status = possible_next[index].copy()
       #update the other guy's status vector resulting from your act
        player2.status.vec_act[stage][1]=self.status.vec_act[stage][0]
        player2.status.vec_act[stage][2]=self.status.vec_act[stage][2]
        player2.status.stage= self.status.stage
        if debug:
           #print "after the decision is made at stage:", stage
           #print self.status.vec_act[stage]
           #print player2.status.vec_act[stage]
            print self.name+" decided to ", game_actions[index]
        return game_actions[index]
